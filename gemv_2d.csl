param x_in : color;     // color for input X from NORTH to kernel
param sentinel : color; // sentinel color for X

// checkerboard color for sending result to EAST
// on rightmost column of PEs, color along which y is streamed out
param send : color;

// checkerboard color for receiving result from WEST
// on leftmost column of PEs, color along with b is streamed in
param recv : color;

// dims of A, X, B chunks on PE
param A_local_dim_x : i16;
param A_local_dim_y : i16;

param X_local_dim_x : i16;
param X_local_dim_y : i16;

param B_local_dim_x : i16;
param B_local_dim_y : i16;

var A = @zeros([A_local_dim_x, A_local_dim_y]f16);
var mul_temp = @zeros([A_local_dim_x]f16);

const dsd_A = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{A_local_dim_x} -> A[i, 0], .wavelet_index_offset=true});
const dsd_mul_temp = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{A_local_dim_x} -> mul_temp[i]});

const dsd_in  = @get_dsd(fabin_dsd,  .{.fabric_color = recv, .extent = B_local_dim_x});
const dsd_out = @get_dsd(fabout_dsd, .{ .fabric_color = send, .extent = B_local_dim_x * B_local_dim_y});

task fmac_task(wlet_data : f16, idx : u16) void {
  @fmach(dsd_mul_temp, dsd_mul_temp, dsd_A, wlet_data, .{.index = idx});
}

task sentinel_task() void {
  @faddh(dsd_out, dsd_in, dsd_mul_temp);
}

comptime {
  @bind_task(fmac_task, x_in);
  @bind_task(sentinel_task, sentinel);

  // recv is blocked to prevent (empty) task from consuming wavelets
  // before dsd_in in sentinel_task consumes them
  @block(recv);
}
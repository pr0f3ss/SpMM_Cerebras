// importing modules and setting up corresponding variables
param c2d_params: comptime_struct;
const mpi_x = @import_module("<collectives_2d/pe>", .{ .dim_params = c2d_params.x });
const mpi_y = @import_module("<collectives_2d/pe>", .{ .dim_params = c2d_params.y });
const mpi_common = @import_module("<collectives_2d/common>", .{ .c2d_params = c2d_params });

const timestamp = @import_module("<time>");
var tsc_start_buffer = @zeros([timestamp.tsc_size_words]u16);
var tsc_end_buffer = @zeros([timestamp.tsc_size_words]u16);

// Task colors
const reduce_color = @get_color(12); // this one is activated as soon as main has finished
const main_color = @get_color(13);
const done_color = @get_color(8); // this color denotes whether C_final is done with the reduction

// Matrix size params
param Nt: u16;
param Kt: u16;
param Mt: u16;
param nnz: u16;

const P = @get_rectangle().width;

// grid values
var px: u16;
var py: u16;


// -------------------------------------------------

// A: sparse N x K matrix
// B: dense K x M matrix (slim: M small)
// C: output N x M matrix

// A grid: Nt x Kt
// B grid: Kt x Mt
// C grid: Nt x Mt

// ======== initialize helper arrays for A ======== 

// holds row index
var A_i = @zeros([nnz]f32); 

// holds col index
var A_j = @zeros([nnz]f32); 

// holds non-zero value and corresponds to A_i and A_j
var A_val = @zeros([nnz]f32); 

// holds grid pointer offset value, beginning at (0,0), (0,1), ...
// Note: To get amount of non-zero values in a grid i we subtract A_grid_ptr[i+1] - A_grid_ptr[i]
var A_grid_ptr = @zeros([P*P]f32); 

// ======== initialize helper arrays for B,C ======== 

// `B_tile` will be populated with initial values by run.py
var B_tile = @zeros([Kt,Mt]f32);
var C_temp = @zeros([Nt,Mt]f32);

var C_final = @zeros([Nt,Mt]f32);

task main() void {

    // initialize mpi vars
    mpi_x.init(&mpi_common.pendings);
    mpi_y.init(&mpi_common.pendings);
    px = mpi_x.pe_id;
    py = mpi_y.pe_id;

    // stores the number of elements in the grid
    var n_elem_grid: u16; 
    n_elem_grid = A_grid_ptr.*[P*px + py + 1] - A_grid_ptr.*[P*px + py];

    // stores the grid pointer
    var grid_ptr: u16;
    grid_ptr = A_grid_ptr.*[P*px + py];

    // iterate over non-zero elements in the grid
    for (@range(u16, n_elem_grid)) |n| {

        // get non-zero value
        const a = A_val.*[grid_ptr + n];

        // get its coordinates
        const a_i = A_i.*[grid_ptr + n];
        const a_j = A_j.*[grid_ptr + n];

        // get B row
        var B_dsd  = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{Mt} -> B_tile[a_j,i] });

        // get C_temp row
        var C_temp = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{Mt} -> C_tile[a_j,i] });

        @fmacs(C_temp, C_temp, B_dsd, a);
    }


    // once all non-zero elements have been considered, activate reduction
    @activate(reduce_color);
}

task reduce() void {
    mpi_x.reduce_fadds(P - 1, @ptrcast([*]f32, &C_temp), @ptrcast([*]f32, &C_final), Nt*Mt, done_color);

    timestamp.get_timestamp(&tsc_end_buffer);
}

comptime {
    @bind_task(main, main_color);
    @bind_task(reduce, reduce_color);
    @activate(main_color);
}
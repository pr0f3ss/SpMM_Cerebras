// importing modules and setting up corresponding variables
param c2d_params: comptime_struct;
const mpi_x = @import_module("<collectives_2d/pe>", .{ .dim_params = c2d_params.x });
const mpi_y = @import_module("<collectives_2d/pe>", .{ .dim_params = c2d_params.y });
const mpi_common = @import_module("<collectives_2d/common>", .{ .c2d_params = c2d_params });

const timestamp = @import_module("<time>");
var tsc_start_buffer = @zeros([timestamp.tsc_size_words]u16);
var tsc_end_buffer = @zeros([timestamp.tsc_size_words]u16);

// Task colors
const gatherparams_color = @get_color(14);
const reduce_color = @get_color(12); // this one is activated as soon as main has finished
const main_color = @get_color(13);
const done_color = @get_color(8); // this color denotes whether C_final is done with the reduction

// Matrix size params
param Nt: u16;
param Kt: u16;
param Mt: u16;
param val_size: u16;
param col_size: u16;
param row_size: u16;

const P = @get_rectangle().width;

// grid values
var px: u16;
var py: u16;


// -------------------------------------------------

// A: sparse N x K matrix
// B: dense K x M matrix (slim: M small)
// C: output N x M matrix

// A grid: Nt x Kt
// B grid: Kt x Mt
// C grid: Nt x Mt

// ======== initialize helper arrays for A ======== 

// holds values
var A_val = @zeros([val_size]f32); 

// holds row index
var A_row_idx = @zeros([row_size]f32); 

// holds column pointer
var A_col_ptr = @zeros([col_size]f32); 

// ======== initialize helper arrays for B,C ======== 

// `B_tile` will be populated with initial values by run.py
var B_tile = @zeros([Kt,Mt]f32);
var C_temp = @zeros([Nt,Mt]f32);

var C_final = @zeros([Nt,Mt]f32);

task main() void {

    // initialize mpi vars
    mpi_x.init(&mpi_common.pendings);
    mpi_y.init(&mpi_common.pendings);
    px = mpi_x.pe_id;
    py = mpi_y.pe_id;


    // iterate over column pointers
    for (@range(u16, col_size-1)) |j| {

        var row_elems = A_col_ptr[j+1] - A_col_ptr[j];

        // iterate over all non-zero rows in the column
        for (@range(u16, row_elems)) |i| {

            // get the reference element index
            var ref_elem_idx = A_col_ptr[j+i];

            // get non-zero value
            const a = A_val[ref_elem_idx];

            // get its coordinates
            const a_i = A_row_idx[ref_elem_idx]; // row
            const a_j = A_col_ptr[i]; // col

            // get B row
            var B_dsd  = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{Mt} -> B_tile[a_j,i] });

            // get C_temp row
            var C_temp = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{Mt} -> C_tile[a_i,i] });

            @fmacs(C_temp, C_temp, B_dsd, a);
        }
    }


    // once all non-zero elements have been considered, activate reduction
    @activate(reduce_color);
}

task reduce() void {
    mpi_x.reduce_fadds(P - 1, @ptrcast([*]f32, &C_temp), @ptrcast([*]f32, &C_final), Nt*Mt, done_color);

    timestamp.get_timestamp(&tsc_end_buffer);
}

task gatherparams() void {
    // todo
}

comptime {
    @bind_task(main, main_color);
    @bind_task(reduce, reduce_color);
    @bind_task(gatherparams, gatherparams_color);
    @activate(main_color);
}
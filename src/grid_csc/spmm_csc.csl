// Performs grid CSC matrix multiplication to compute C_temp = A*B (of local PE)
//     C_temp := A*B
//
// @param[in] A_val          values in the local matrix A (may be padded with -1 values)
// @param[in] A_row_idx      row index array of the local matrix A (may be padded with -1 values)
// @param[in] A_col_ptr      column pointer array of the local matrix A (may be padded with -1 values)
// @param[in] B              array of dimension Kt x M
// @param[in,out] C_temp     array of dimension Nt x M

param A_val_len : i16 ;     // number of values in the local matrix A
param A_rowidx_len : i16 ;  // length of row index array of the local matrix A
param A_colptr_len : i16 ;  // length of column pointer array of the local matrix A

param Nt : i16 ;            // row dimension of C_temp
param Kt : i16 ;            // row dimension of local B
param M  : i16 ;            // column dimension of local B and C_temp

fn spmm_csc_f32(A_val: *[A_val_len]f32, A_row_idx: *[A_rowidx_len]i32, A_col_ptr: *[A_colptr_len]i32, B: *[Kt, M]f32, C_temp: *[Nt, M]f32) void { 

    // iterate over column pointers
    for (@range(u16, A_colptr_len-1)) |j| {

        // get number of non-zero rows in the current column
        var row_elems = (A_col_ptr.*)[j+1] - (A_col_ptr.*)[j];

        var row_idx_start = (A_col_ptr.*)[j];

        if((A_col_ptr.*)[j+1] == -1){
            // todo: exit if we reach padded end
        }

        // iterate over all non-zero rows in the current column
        for (@range(u16, row_elems)) |i| {

            // get the reference element row index
            var ref_elem_row_idx = (A_row_idx.*)[row_idx_start+i];

            // extract the referenced non-zero value
            const a = (A_val.*)[row_idx_start+i];

            // get a's coordinates
            const a_i = ref_elem_row_idx;   // row
            const a_j = j;                  // col

            // get B row
            var B_dsd  = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{M} -> B_tile[a_j,i] });

            // get C_temp row to write into
            var C_temp = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{M} -> C_tile[a_i,i] });

            @fmacs(C_temp, C_temp, B_dsd, a);
        }

    }

}

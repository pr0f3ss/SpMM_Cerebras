// This program computes A*B on a height-by-width PE rectangle
// The matrix A in CSC format is distributed to every PE via memcpy
// The matrix B is distributed to first row PEs via memcpy
// Pw.0, ..., Pw.h send out the result C_final via memcpy, where h = height-1 and w = width-1.
// Note that this is the right-hand side column of PEs
//
// Each PE receives the local matrices representing A and B and computes A*B locally, then performs a row reduction
// The last column of PEs finally contains C_final and sends its result back to the host
//

// global routing colors
param LAUNCH_ID: i16;

// Lengths
//    A_val     A_val_len x 1
//    A_rowidx  A_rowidx_len x 1
//    A_colptr  A_colptr_len x 1
//    B         Kt x M
//    C_temp    Nt x M
//    C_final   Nt x M
//
// The unit test sets up the parameters Nt, Kt and M via cslc
//    Nt = N / height
//    Kt  = K / width
//    M
// where N, K and M are dimensions of global tensors A_global, B_global and C_global
//    A_global is N x K (remember its represented in CSC format)
//    B_global is K x M
//    C_global is N x M


param Nt:i32;         
param Kt:i32; 
param M:i32;  

param A_val_len:i32;
param A_rowidx_len:i32;
param A_colptr_len:i32;

param width: i16;
param height: i16;

const LAUNCH : color = @get_color(LAUNCH_ID);

const RXACT_B: color  = @get_color(8) ;  // receive B
const C_TEMP_REDUCE: color     = @get_color(9) ;  // row reduction

// local tasks
const COMP: color     = @get_color(12) ;
const REDUCE: color   = @get_color(13) ;
const DONE: color     = @get_color(14) ;

// neither routing color nor local task
const NONE: color     = @get_color(15) ; // NONE is don't care (neither routing color nor entrypoint)
                             // the compiler emits an error for un-initialized colors or parameters
                             // binding a non-routing local color to NONE to avoid the compilation error
const EXIT: color     = @get_color(17);

const memcpy = @import_module( "<memcpy_multi/get_params>", .{
    .width = width,
    .height = height
    });

// We use a named struct type to be able to assign PE's its route efficiently
const s_route = struct {
  RXACT_B: color,
  TXACT_B: color,
  RXACT_C: color,
  TXACT_C: color
};


layout{

    // step 1: configure the rectangle which does not include halo
    @set_rectangle(width, height);

    // set common parameters that are shared across every PE
    const comm_params = .{
        .COMP=COMP,
        .REDUCE=REDUCE,
        .DONE=DONE,
        .Nt=Nt,
        .Kt=Kt,
        .M=M,
        .A_val_len=A_val_len,
        .A_rowidx_len=A_rowidx_len,
        .A_colptr_len=A_colptr_len,
        .height = height,
        .width = width,
        .LAUNCH = LAUNCH,
        .EXIT = EXIT
    };

    // The routing and coloring works as follows
    //
    // ====== C_temp routing ======
    // First column of PEs:         Only send out C via C_TEMP_REDUCE color
    // Intermediate columns of PEs: Receive and send out C via C_TEMP_REDUCE color
    // Last column of PEs:          Only receive C via C_TEMP_REDUCE color
    // ====== C_temp colors ======
    // First column of PEs:         .{ .rx = .{RAMP},  .tx = .{EAST} }    
    // Intermediate columns of PEs: .{ .rx = .{WEST}, .tx = .{RAMP, EAST} }
    // Last column of PEs:          .{ .rx = .{WEST}, .tx = .{RAMP} }
    //
    // ====== B routing ======
    // First row of PEs:            Only send B via RXACT_B color
    // Intermediate columns of PEs: Receive and send B via RXACT_B color
    // Last row of PEs:             Only receive B via RXACT_B color
    // ====== B colors ======
    // First row of PEs:            .{ .rx = .{RAMP},  .tx = .{SOUTH} }    
    // Intermediate row of PEs:     .{ .rx = .{NORTH}, .tx = .{RAMP, SOUTH} }
    // Last row of PEs:             .{ .rx = .{NORTH}, .tx = .{RAMP} }   

    const height_1 = height - 1;
    const width_1 = width - 1;  

    for (@range(i16, width)) |pe_x| {

        // Params are retrieved for the whole PE column
        const memcpyParams_col = memcpy.get_params(pe_x);

        for (@range(i16, height)) |pe_y| {
            
            // step 2: compile csl code for a set of PEx.y and generate out_x_y.elf
            //   format: @set_tile_code(x, y, code.csl, param_binding);
            
            // Since every variable has to be known at compile time, this gets really messy.
            // Could be generated on a PE basis by a separate program (in Python) and pasted into this
            // for better readability
            // Refer to comments above for specific routing data
            if(pe_x == 0){
                const pe_color_config_route_C = .{ .rx = .{RAMP},  .tx = .{EAST} };

                if(pe_y == 0){
                    // px = 0, pe_y = 0

                    const pe_color_config_route_B = .{ .rx = .{RAMP},  .tx = .{SOUTH} };

                    const route = @concat_structs(
                        .{ .RXACT_B = NONE, .TXACT_B=RXACT_B, .RXACT_C = NONE, .TXACT_C = C_TEMP_REDUCE},
                        .{ .memcpyParams = memcpyParams_col } );
                    
                    @set_tile_code(pe_x, pe_y, "spmm_csc_memcpy.csl", @concat_structs(route, comm_params) );
                    @set_color_config(pe_x, pe_y, C_TEMP_REDUCE, .{ .routes = pe_color_config_route_C });
                    @set_color_config(pe_x, pe_y, RXACT_B, .{ .routes = pe_color_config_route_B });


                }else if(pe_y == height-1){
                    // px = 0, pe_y = height-1

                    const pe_color_config_route_B = .{ .rx = .{NORTH}, .tx = .{RAMP} };

                    const route = @concat_structs(
                        .{ .RXACT_B = RXACT_B, .TXACT_B=NONE, .RXACT_C = NONE, .TXACT_C = C_TEMP_REDUCE},
                        .{ .memcpyParams = memcpyParams_col } );
                    
                    @set_tile_code(pe_x, pe_y, "spmm_csc_memcpy.csl", @concat_structs(route, comm_params) );
                    @set_color_config(pe_x, pe_y, C_TEMP_REDUCE, .{ .routes = pe_color_config_route_C });
                    @set_color_config(pe_x, pe_y, RXACT_B, .{ .routes = pe_color_config_route_B });


                }else{
                    // px = 0, pe_y = between

                    const pe_color_config_route_B = .{ .rx = .{NORTH}, .tx = .{RAMP, SOUTH} };

                    const route = @concat_structs(
                        .{ .RXACT_B = RXACT_B, .TXACT_B=RXACT_B, .RXACT_C = NONE, .TXACT_C = C_TEMP_REDUCE},
                        .{ .memcpyParams = memcpyParams_col } );
                    
                    @set_tile_code(pe_x, pe_y, "spmm_csc_memcpy.csl", @concat_structs(route, comm_params) );
                    @set_color_config(pe_x, pe_y, C_TEMP_REDUCE, .{ .routes = pe_color_config_route_C });
                    @set_color_config(pe_x, pe_y, RXACT_B, .{ .routes = pe_color_config_route_B });
                }

            }else if(pe_x == width-1){
                const pe_color_config_route_C = .{ .rx = .{WEST}, .tx = .{RAMP} };

                if(pe_y == 0){
                    // px = width-1, pe_y = 0

                    const pe_color_config_route_B = .{ .rx = .{RAMP},  .tx = .{SOUTH} };

                    const route = @concat_structs(
                        .{ .RXACT_B = NONE, .TXACT_B=RXACT_B, .RXACT_C = C_TEMP_REDUCE, .TXACT_C = NONE},
                        .{ .memcpyParams = memcpyParams_col } );
                    
                    @set_tile_code(pe_x, pe_y, "spmm_csc_memcpy.csl", @concat_structs(route, comm_params) );
                    @set_color_config(pe_x, pe_y, C_TEMP_REDUCE, .{ .routes = pe_color_config_route_C });
                    @set_color_config(pe_x, pe_y, RXACT_B, .{ .routes = pe_color_config_route_B });


                }else if(pe_y == height-1){
                    // px = width-1, pe_y = height-1

                    const pe_color_config_route_B = .{ .rx = .{NORTH}, .tx = .{RAMP} };

                    const route = @concat_structs(
                        .{ .RXACT_B = RXACT_B, .TXACT_B=NONE, .RXACT_C = C_TEMP_REDUCE, .TXACT_C = NONE},
                        .{ .memcpyParams = memcpyParams_col } );
                    
                    @set_tile_code(pe_x, pe_y, "spmm_csc_memcpy.csl", @concat_structs(route, comm_params) );
                    @set_color_config(pe_x, pe_y, C_TEMP_REDUCE, .{ .routes = pe_color_config_route_C });
                    @set_color_config(pe_x, pe_y, RXACT_B, .{ .routes = pe_color_config_route_B });


                }else{
                    // px = width-1, pe_y = between

                    const pe_color_config_route_B = .{ .rx = .{NORTH}, .tx = .{RAMP, SOUTH} };

                    const route = @concat_structs(
                        .{ .RXACT_B = RXACT_B, .TXACT_B=RXACT_B, .RXACT_C = C_TEMP_REDUCE, .TXACT_C = NONE},
                        .{ .memcpyParams = memcpyParams_col } );
                    
                    @set_tile_code(pe_x, pe_y, "spmm_csc_memcpy.csl", @concat_structs(route, comm_params) );
                    @set_color_config(pe_x, pe_y, C_TEMP_REDUCE, .{ .routes = pe_color_config_route_C });
                    @set_color_config(pe_x, pe_y, RXACT_B, .{ .routes = pe_color_config_route_B });
                }       
            }else{
                const pe_color_config_route_C = .{ .rx = .{WEST}, .tx = .{RAMP, EAST} };


                if(pe_y == 0){
                    // px = between, pe_y = 0

                    const pe_color_config_route_B = .{ .rx = .{RAMP},  .tx = .{SOUTH} };

                    const route = @concat_structs(
                        .{ .RXACT_B = NONE, .TXACT_B=RXACT_B, .RXACT_C = C_TEMP_REDUCE, .TXACT_C = C_TEMP_REDUCE},
                        .{ .memcpyParams = memcpyParams_col } );
                    
                    @set_tile_code(pe_x, pe_y, "spmm_csc_memcpy.csl", @concat_structs(route, comm_params) );
                    @set_color_config(pe_x, pe_y, C_TEMP_REDUCE, .{ .routes = pe_color_config_route_C });
                    @set_color_config(pe_x, pe_y, RXACT_B, .{ .routes = pe_color_config_route_B });


                }else if(pe_y == height-1){
                    // px = between, pe_y = height-1

                    const pe_color_config_route_B = .{ .rx = .{NORTH}, .tx = .{RAMP} };

                    const route = @concat_structs(
                        .{ .RXACT_B = RXACT_B, .TXACT_B=NONE, .RXACT_C = C_TEMP_REDUCE, .TXACT_C = C_TEMP_REDUCE},
                        .{ .memcpyParams = memcpyParams_col } );
                    
                    @set_tile_code(pe_x, pe_y, "spmm_csc_memcpy.csl", @concat_structs(route, comm_params) );
                    @set_color_config(pe_x, pe_y, C_TEMP_REDUCE, .{ .routes = pe_color_config_route_C });
                    @set_color_config(pe_x, pe_y, RXACT_B, .{ .routes = pe_color_config_route_B });


                }else{
                    // px = between, pe_y = between

                    const pe_color_config_route_B = .{ .rx = .{NORTH}, .tx = .{RAMP, SOUTH} };

                    const route = @concat_structs(
                        .{ .RXACT_B = RXACT_B, .TXACT_B=RXACT_B, .RXACT_C = C_TEMP_REDUCE, .TXACT_C = C_TEMP_REDUCE},
                        .{ .memcpyParams = memcpyParams_col } );
                    
                    @set_tile_code(pe_x, pe_y, "spmm_csc_memcpy.csl", @concat_structs(route, comm_params) );
                    @set_color_config(pe_x, pe_y, C_TEMP_REDUCE, .{ .routes = pe_color_config_route_C });
                    @set_color_config(pe_x, pe_y, RXACT_B, .{ .routes = pe_color_config_route_B });
                }          
            }
            
        }
    }

    // export symbol name
    @export_name("A_val", [*]f32, true);
    @export_name("A_row_idx", [*]f32, true);
    @export_name("A_col_ptr", [*]f32, true);
    @export_name("B", [*]f32, true);
    @export_name("C_temp", [*]f32, true);
}
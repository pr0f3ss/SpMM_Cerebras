param pe_id: u16;
param step: u16;
param reduce_recv_color: color;
param reduce_send_color: color;
param notify_color: color;

const rect_height = @get_rectangle().height;
const rect_width = @get_rectangle().width;

const x_color = @get_color(14);
const Nx = 1; //Vector length

var data = @constants([Nx]f32, 1.0);
var notify_data = @constants([1]u32, 1);


var memDsd = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{Nx} -> data[i]});
var memNotifyDsd = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{1} -> notify_data[i]});
var sendDsd = @get_dsd(fabout_dsd, .{.extent = Nx, .fabric_color = reduce_send_color});
var recvDsd = @get_dsd(fabin_dsd, .{.extent = Nx, .fabric_color = reduce_recv_color});
var recvNotifyDsd = @get_dsd(fabin_dsd, .{.extent = 1, .fabric_color = notify_color});
var sendNotifyDsd = @get_dsd(fabout_dsd, .{.extent = 1, .fabric_color = notify_color});
var ctrlDsd = @get_dsd(fabout_dsd, .{.extent = 1, .fabric_color = reduce_send_color, .control = true});

// Opcodes for potentially updating switches
const opcode_nop = 0;
const opcode_switch_advance = 1;
const opcode_switch_reset = 2;
const opcode_teardown = 3;

// Helper function to construct the payload of the control wavelet.
// args:
//    ceFilter: a filter bit to disable transmission from the destination
//              router to the destination CE,
//    opcode: switching opcode (see comment above), and
//    data: 16-bit wavelet data
fn ctrl(ce_filter: bool, opcode: i16, data: u16) u32 {
  const six = @as(u32, 6);
  const eight = @as(u32, 8);
  const sixteen = @as(u32, 16);

  const hi_word = @as(u32, 1) |
                  @as(u32, opcode) << six |
                  @as(u32, ce_filter) << eight;

  const lo_word = @as(u32, data);
  return hi_word << sixteen | lo_word;
}


// Reduction Task
task task_x() void {
  if ((pe_id + 1) % step == 0) {
    @fmovs(sendDsd, memDsd);
    @mov32(ctrlDsd, comptime ctrl(true, opcode_switch_advance, 0x00));
  } else if (pe_id % step == 1) {
    @fadds(sendDsd, recvDsd, memDsd);
    @fmovs(sendNotifyDsd, 1.0);
  } else if (pe_id % step != 0){
    @fadds(sendDsd, recvDsd, memDsd);
    @mov32(ctrlDsd, comptime ctrl(true, opcode_switch_advance, 0x00));
  } else if (pe_id + step == rect_width) {
    @fadds(memDsd, recvDsd, memDsd);
    @mov32(memNotifyDsd, recvNotifyDsd);
    @fmovs(sendDsd, memDsd);
  } else if (pe_id != 0) {
    @fadds(memDsd, recvDsd, memDsd);
    @mov32(memNotifyDsd, recvNotifyDsd);
    @fadds(sendDsd, recvDsd, memDsd);
  } else {
    @fadds(memDsd, recvDsd, memDsd);
    @fadds(memDsd, recvDsd, memDsd);
  }
}

const switches = .{
  .pos1 = .{ .tx = WEST },
  .current_switch_pos = 0,
  .ring_mode = false
};
comptime {
  @bind_task(task_x, x_color);
  @activate(x_color);
  @block(reduce_recv_color);
  @block(notify_color);
  @set_local_color_config(reduce_recv_color, .{.routes = .{.rx = .{RAMP, EAST}, .tx = if ((pe_id + 1) % step == 0) .{WEST} else .{RAMP}}, .switches = switches});
  @set_local_color_config(reduce_send_color, .{.routes = .{.rx = .{RAMP, EAST}, .tx = .{WEST}}});
  @set_local_color_config(notify_color, .{.routes = .{.rx = if (pe_id % step == 1) .{RAMP} else .{ WEST }, .tx = if (pe_id % step == 0) .{RAMP} else .{EAST}}});
}